// Generated by CoffeeScript 1.6.3
(function() {
  var Axis, D, Painter, Q, QueueEvent, X, Y, center, clog, cols, dashed_box, draw, drawer, export_to_latex, get_cur_rel_pos, init_op, locate_mouse, mk_table, op, ops, redraw, rows, sz_cfg, _i, _len;

  clog = console.log;

  draw = SVG('drawing').size(360, 360);

  window.ops = [];

  ops = window.ops;

  init_op = [['line', 1, 1, 3, 1], ['line', 1, 2, 4, 2], ['line', 1, 3, 3, 3], ['black-dot', 1, 1], ['black-dot', 2, 2], ['black-dot', 3, 2], ['white-dot', 3, 3], ['black-dot', 4, 2], ['targ', 1, 2], ['targ', 3, 1], ['gate', 1, 3, 'U'], ['qswap', 4, 1]];

  Axis = (function() {
    function Axis(_default, cnt) {
      var i, _i;
      this["default"] = _default;
      this.dx = [0];
      for (i = _i = 1; 1 <= cnt ? _i <= cnt : _i >= cnt; i = 1 <= cnt ? ++_i : --_i) {
        this.dx.push(this["default"]);
      }
      this.sum = function(x, y) {
        return x + y;
      };
      this.upd_xs();
    }

    Axis.prototype.upd_xs = function() {
      var cnt, i, x, _i, _j, _len, _ref, _ref1;
      this.last = 0;
      this.xs = [];
      this.rep = [];
      cnt = 0;
      _ref = this.dx;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        for (x = _j = 0, _ref1 = i - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          this.rep.push(cnt);
        }
        this.last += i;
        this.xs.push(this.last);
        cnt += 1;
      }
      return clog("xs: " + this.xs);
    };

    Axis.prototype.set_default = function(_default) {
      this["default"] = _default;
    };

    Axis.prototype.set = function(col, width) {
      return this.dx[col] = width;
    };

    Axis.prototype.get = function(col) {
      return this.dx[col];
    };

    Axis.prototype.left = function(x) {
      if (x > this.xs.length) {
        x = this.xs.length;
      }
      return this.xs[x - 1];
    };

    Axis.prototype.right = function(x) {
      if (x >= this.xs.length) {
        return this.last;
      }
      return this.xs[x];
    };

    Axis.prototype.center = function(x) {
      return this.dx[x] / 2 + this.xs[x - 1];
    };

    Axis.prototype.locate = function(x) {
      if (x >= this.last) {
        return this.xs.length;
      }
      return this.rep[x];
    };

    return Axis;

  })();

  sz_cfg = {
    'circle': 12,
    'gate': 40,
    'target': 30,
    'qswap': 5
  };

  cols = 6;

  rows = 6;

  X = new Axis(60, rows);

  Y = new Axis(60, cols);

  center = function(x, y) {
    clog("center " + x + " " + y + " " + (X.center(x)) + " " + (Y.center(y)));
    return [X.center(x), Y.center(y)];
  };

  Painter = (function() {
    function Painter(draw, ops) {
      this.draw = draw;
      this.ops = ops;
    }

    Painter.prototype.black_dot = function(x, y) {
      var rad, xc, yc, _ref;
      rad = sz_cfg['circle'] / 2;
      _ref = center(x, y), xc = _ref[0], yc = _ref[1];
      clog("black-dot " + xc + " " + yc + " " + x + " " + y);
      return draw.circle(rad * 2).move(yc - rad, xc - rad);
    };

    Painter.prototype.white_dot = function(x, y) {
      var rad, xc, yc, _ref;
      rad = sz_cfg['circle'] / 2;
      _ref = center(x, y), xc = _ref[0], yc = _ref[1];
      return draw.circle(rad * 2).move(yc - rad, xc - rad).attr({
        'stroke-width': 2,
        'fill': 'white',
        'fill-opacity': 1
      });
    };

    Painter.prototype.targ = function(x, y) {
      var rad, xc, yc, _ref;
      rad = sz_cfg['target'] / 2;
      _ref = center(x, y), xc = _ref[0], yc = _ref[1];
      draw.circle(rad * 2).move(yc - rad, xc - rad).attr({
        'stroke-width': 2,
        'fill-opacity': 0
      });
      draw.line(yc - rad, xc, yc + rad, xc).stroke({
        width: 1
      });
      return draw.line(yc, xc - rad, yc, xc + rad).stroke({
        width: 1
      });
    };

    Painter.prototype.fix_line = function(x1, y1, x2, y2) {
      var cmd, op, x, y, _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        cmd = op[0];
        if (cmd === 'black-dot' || cmd === 'white-dot' || cmd === 'targ' || cmd === 'gate') {
          _ref = op.slice(1, 3), x = _ref[0], y = _ref[1];
          if ((((x1 <= x && x <= x2)) || ((x1 >= x && x >= x2))) && (((y1 <= y && y <= y2)) || ((y1 >= y && y >= y2)))) {
            _results.push(this.add(op, false));
          } else {
            _results.push(void 0);
          }
        } else if (cmd === 'multigate') {
          _results.push(this.add(op, false));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Painter.prototype.line = function(x1, y1, x2, y2) {
      var x1c, x2c, y1c, y2c, _ref, _ref1;
      _ref = center(x1, y1), x1c = _ref[0], y1c = _ref[1];
      _ref1 = center(x2, y2), x2c = _ref1[0], y2c = _ref1[1];
      draw.line(y1c, x1c, y2c, x2c).stroke({
        width: 1
      });
      return this.fix_line(x1, y1, x2, y2);
    };

    Painter.prototype.qswap = function(x, y) {
      var d, xc, yc, _ref;
      d = sz_cfg['qswap'];
      _ref = center(x, y), xc = _ref[0], yc = _ref[1];
      draw.line(yc - d, xc - d, yc + d, xc + d).stroke({
        width: 3
      });
      return draw.line(yc + d, xc - d, yc - d, xc + d).stroke({
        width: 3
      });
    };

    Painter.prototype.gate = function(x, y, txt) {
      var d, xc, yc, _ref;
      d = sz_cfg['gate'] / 2;
      _ref = center(x, y), xc = _ref[0], yc = _ref[1];
      draw.rect(d * 2, d * 2).move(yc - d, xc - d).attr({
        'stroke': 'black',
        'fill': 'white',
        'fill-opacity': 1
      });
      return draw.image("http://frog.isima.fr/cgi-bin/bruno/tex2png--10.cgi?" + txt, d, d).move(yc - d / 2, xc - d / 2);
    };

    Painter.prototype.multigate = function(c, x, y, txt) {
      var d, lc, uc, xc, _ref;
      if (y < x) {
        _ref = [y, x], x = _ref[0], y = _ref[1];
      }
      d = sz_cfg['gate'] / 2;
      xc = Y.center(c);
      lc = X.center(y);
      uc = X.center(x);
      draw.rect(d * 2, d * 2 + lc - uc).move(xc - d, uc - d).attr({
        'stroke': 'black',
        'fill': 'white',
        'fill-opacity': 1
      });
      return draw.image("http://frog.isima.fr/cgi-bin/bruno/tex2png--10.cgi?" + txt, d, d).move(xc - 10, (lc + uc) / 2 - 10);
    };

    Painter.prototype.add = function(op, p) {
      var c, cmd, txt, x, x1, x2, y, y1, y2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      cmd = op[0];
      if (p) {
        ops.push(op);
      }
      if (cmd === 'black-dot') {
        _ref = op.slice(1, 3), x = _ref[0], y = _ref[1];
        return this.black_dot(x, y);
      } else if (cmd === 'white-dot') {
        _ref1 = op.slice(1, 3), x = _ref1[0], y = _ref1[1];
        return this.white_dot(x, y);
      } else if (cmd === 'line') {
        _ref2 = op.slice(1, 5), x1 = _ref2[0], y1 = _ref2[1], x2 = _ref2[2], y2 = _ref2[3];
        return this.line(x1, y1, x2, y2);
      } else if (cmd === 'targ') {
        _ref3 = op.slice(1, 3), x = _ref3[0], y = _ref3[1];
        return this.targ(x, y);
      } else if (cmd === 'gate') {
        _ref4 = op.slice(1, 4), x = _ref4[0], y = _ref4[1], txt = _ref4[2];
        return this.gate(x, y, txt);
      } else if (cmd === 'qswap') {
        _ref5 = op.slice(1, 3), x = _ref5[0], y = _ref5[1];
        return this.qswap(x, y);
      } else if (cmd === 'multigate') {
        _ref6 = op.slice(1, 5), c = _ref6[0], x = _ref6[1], y = _ref6[2], txt = _ref6[3];
        return this.multigate(c, x, y, txt);
      }
    };

    return Painter;

  })();

  D = new Painter(draw);

  dashed_box = null;

  redraw = function() {
    var op, _i, _len, _results;
    draw.clear();
    _results = [];
    for (_i = 0, _len = ops.length; _i < _len; _i++) {
      op = ops[_i];
      _results.push(D.add(op, false));
    }
    return _results;
  };

  for (_i = 0, _len = init_op.length; _i < _len; _i++) {
    op = init_op[_i];
    D.add(op, true);
  }

  redraw();

  locate_mouse = function(x, y) {
    return [Y.locate(y), X.locate(x)];
  };

  window.cancel_op = function() {
    if (ops.length === 0) {
      return clog('empty operation!');
    } else {
      ops = ops.slice(0, -1);
      return redraw();
    }
  };

  QueueEvent = (function() {
    function QueueEvent() {
      this.Q = [];
      this.func = null;
      this.cnt = 0;
    }

    QueueEvent.prototype.push = function(args) {
      clog("push: " + args);
      this.Q.push(args);
      if (this.Q.length >= this.cnt && this.func) {
        this.func(this.Q.slice(0, +(this.cnt - 1) + 1 || 9e9));
        this.Q = [];
        this.func = null;
      }
      clog("Queue Length " + this.Q.length);
      return $("#QLen").val("" + this.Q.length + " drd");
    };

    QueueEvent.prototype.bind = function(func, cnt) {
      this.func = func;
      this.cnt = cnt;
      this.Q = [];
      return $("#QLen").val("" + this.Q.length + " rdr");
    };

    return QueueEvent;

  })();

  window.Q = new QueueEvent;

  Q = window.Q;

  drawer = $("#drawing");

  get_cur_rel_pos = function(event) {
    var x, y;
    x = parseInt(event.pageX) - drawer.position().top;
    y = parseInt(event.pageY) - drawer.position().left;
    return [x, y];
  };

  drawer.mousemove(function(event) {
    var Bx, By, x, x1, x2, y, y1, y2, _ref, _ref1;
    _ref = get_cur_rel_pos(event), x = _ref[0], y = _ref[1];
    $("#mouse-position").text("" + x + " " + y);
    if (dashed_box) {
      dashed_box.remove();
    }
    _ref1 = locate_mouse(x, y), Bx = _ref1[0], By = _ref1[1];
    x1 = X.left(Bx);
    x2 = X.right(Bx);
    y1 = Y.left(By);
    y2 = Y.right(By);
    clog("" + Bx + " " + By);
    return dashed_box = draw.rect(y2 - y1, x2 - x1).move(y1, x1).attr({
      'stroke': 'black',
      "stroke-dasharray": [2, 2],
      'fill': 'white',
      'fill-opacity': 0
    });
  });

  drawer.click(function(event) {
    var x, y, _ref;
    _ref = get_cur_rel_pos(event), x = _ref[0], y = _ref[1];
    return Q.push(locate_mouse(x, y));
  });

  drawer.css({
    position: "absolute"
  });

  window.add_black_dot = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0], x = _ref[0], y = _ref[1];
      return D.add(['black-dot', x, y], true);
    };
    return Q.bind(func, 1);
  };

  window.add_white_dot = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0], x = _ref[0], y = _ref[1];
      return D.add(['white-dot', x, y], true);
    };
    return Q.bind(func, 1);
  };

  window.add_targ = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0], x = _ref[0], y = _ref[1];
      return D.add(['targ', x, y], true);
    };
    return Q.bind(func, 1);
  };

  window.add_qswap = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0], x = _ref[0], y = _ref[1];
      return D.add(['qswap', x, y], true);
    };
    return Q.bind(func, 1);
  };

  window.add_gate = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0], x = _ref[0], y = _ref[1];
      return D.add(['gate', x, y, $('#gate').val()], true);
    };
    return Q.bind(func, 1);
  };

  window.add_multigate = function() {
    var func;
    func = function(arg) {
      var x1, x2, y1, y2, _ref, _ref1;
      _ref = arg[0], x1 = _ref[0], y1 = _ref[1];
      _ref1 = arg[1], x2 = _ref1[0], y2 = _ref1[1];
      if (y1 === y2) {
        return D.add(['multigate', y1, x1, x2, $('#gate').val()], true);
      }
    };
    return Q.bind(func, 2);
  };

  window.add_line = function() {
    var func;
    func = function(arg) {
      var x1, x2, y1, y2, _ref, _ref1;
      _ref = arg[0], x1 = _ref[0], y1 = _ref[1];
      _ref1 = arg[1], x2 = _ref1[0], y2 = _ref1[1];
      if (y1 === y2 || x1 === x2) {
        return D.add(['line', x1, y1, x2, y2], true);
      }
    };
    return Q.bind(func, 2);
  };

  clog("rdr " + (X.locate(301)));

  export_to_latex = function() {};

  mk_table = function() {
    var elem, h, i, inner, j, rem, s, style, tab, w, _j, _k;
    tab = $("table");
    rem = 20;
    for (i = _j = 0; 0 <= rows ? _j <= rows : _j >= rows; i = 0 <= rows ? ++_j : --_j) {
      h = i === 0 ? rem : X.get(i);
      s = "<tr height=" + (h - 2) + "px>";
      for (j = _k = 0; 0 <= cols ? _k <= cols : _k >= cols; j = 0 <= cols ? ++_k : --_k) {
        elem = i === 0 ? "th" : "td";
        style = j === 0 ? 'style="border-right: 2px solid #CCC"' : "";
        w = j === 0 ? rem : Y.get(j);
        inner = (i === 0 && j > 0) || (i > 0 && j === 0) ? i + j : "";
        s += "<" + elem + " width=" + (w - 4) + "px " + style + "> " + inner + " </" + elem + ">";
      }
      s += '</tr>';
      tab.append(s);
    }
    tab.tableresizer({
      row_border: "2px solid #CCC",
      col_border: "2px solid #CCC"
    });
    return drawer.offset({
      top: tab.offset().top + rem + 5,
      left: tab.offset().left + rem + 5
    });
  };

  mk_table();

}).call(this);
