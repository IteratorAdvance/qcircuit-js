// Generated by CoffeeScript 1.6.3
(function() {
  var C_size, D, D_size, Painter, Q, QueueEvent, U_size, clog, dashed_box, dist, draw, drawer_dom, init_grids, init_op, locate_mouse, op, ops, redraw, _i, _len,
    __slice = [].slice;

  clog = console.log;

  draw = SVG('drawing').size('300', '300');

  dist = 60;

  U_size = 40;

  C_size = 30;

  D_size = 12;

  clog("ck");

  init_grids = function() {
    var i, _i, _results;
    _results = [];
    for (i = _i = 1; _i <= 4; i = ++_i) {
      _results.push(draw.line(0, i * dist, 4 * dist, i * dist).stroke({
        width: 2
      }));
    }
    return _results;
  };

  window.ops = [];

  ops = window.ops;

  init_op = [['line', 1, 1, 3], ['line', 2, 1, 4], ['line', 3, 1, 3], ['black-dot', 1, 1], ['black-dot', 2, 2], ['black-dot', 3, 2], ['white-dot', 3, 3], ['black-dot', 4, 2], ['oplus', 1, 2], ['oplus', 3, 1], ['text', 1, 3, 'U']];

  Painter = (function() {
    function Painter(draw, ops) {
      this.draw = draw;
      this.ops = ops;
    }

    Painter.prototype.black_dot = function(x, y) {
      return draw.circle(D_size).move(y * dist - D_size / 2, x * dist - D_size / 2);
    };

    Painter.prototype.white_dot = function(x, y) {
      return draw.circle(D_size).move(y * dist - D_size / 2, x * dist - D_size / 2).attr({
        'stroke-width': 2,
        'fill': 'white',
        'fill-opacity': 1
      });
    };

    Painter.prototype.oplus = function(x, y) {
      draw.circle(C_size).move(y * dist - C_size / 2, x * dist - C_size / 2).attr({
        'stroke-width': 2,
        'fill-opacity': 0
      });
      draw.line(y * dist - C_size / 2, x * dist, y * dist + C_size / 2, x * dist).stroke({
        width: 1
      });
      return draw.line(y * dist, x * dist - C_size / 2, y * dist, x * dist + C_size / 2).stroke({
        width: 1
      });
    };

    Painter.prototype.line = function(c, x, y) {
      return draw.line(c * dist, x * dist, c * dist, y * dist).stroke({
        width: 1
      });
    };

    Painter.prototype.text = function(x, y, txt) {
      draw.rect(U_size, U_size).move(y * dist - U_size / 2, x * dist - U_size / 2).attr({
        'stroke': 'black',
        'fill': 'white',
        'fill-opacity': 1
      });
      return draw.image("http://frog.isima.fr/cgi-bin/bruno/tex2png--10.cgi?" + txt, 20, 20).move(y * dist - 10, x * dist - 10);
    };

    Painter.prototype.add = function(op, p) {
      var c, cmd, txt, x, y, _ref, _ref1, _ref2, _ref3, _ref4;
      cmd = op[0];
      if (p) {
        ops.push(op);
      }
      if (cmd === 'black-dot') {
        _ref = op.slice(1, 3), x = _ref[0], y = _ref[1];
        return this.black_dot(x, y);
      } else if (cmd === 'white-dot') {
        _ref1 = op.slice(1, 3), x = _ref1[0], y = _ref1[1];
        return this.white_dot(x, y);
      } else if (cmd === 'line') {
        _ref2 = op.slice(1, 4), c = _ref2[0], x = _ref2[1], y = _ref2[2];
        return this.line(c, x, y);
      } else if (cmd === 'oplus') {
        _ref3 = op.slice(1, 3), x = _ref3[0], y = _ref3[1];
        return this.oplus(x, y);
      } else if (cmd === 'text') {
        _ref4 = op.slice(1, 4), x = _ref4[0], y = _ref4[1], txt = _ref4[2];
        return this.text(x, y, txt);
      }
    };

    return Painter;

  })();

  D = new Painter(draw);

  dashed_box = null;

  redraw = function() {
    var op, _i, _len, _results;
    clog('redraw' + ops);
    draw.clear();
    init_grids();
    _results = [];
    for (_i = 0, _len = ops.length; _i < _len; _i++) {
      op = ops[_i];
      _results.push(D.add(op(false)));
    }
    return _results;
  };

  for (_i = 0, _len = init_op.length; _i < _len; _i++) {
    op = init_op[_i];
    D.add(op(true));
  }

  redraw();

  locate_mouse = function(x, y) {
    return [Math.floor(y / dist + 0.5), Math.floor(x / dist + 0.5)];
  };

  window.cancel_op = function() {
    if (ops.length === 0) {
      return clog('empty operation!');
    } else {
      ops = ops.slice(0, -1);
      return redraw();
    }
  };

  QueueEvent = (function() {
    function QueueEvent() {
      this.Q = [];
      this.func = null;
      this.cnt = 0;
    }

    QueueEvent.prototype.push = function() {
      var args, func;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.Q.push([args]);
      clog("QE" + this.Q);
      if (this.Q.length >= this.cnt && this.func) {
        this.func(this.Q.slice(0, +(this.cnt - 1) + 1 || 9e9));
        this.Q = [];
        return func = null;
      }
    };

    QueueEvent.prototype.bind = function(func, cnt) {
      this.func = func;
      this.cnt = cnt;
      return this.Q = [];
    };

    return QueueEvent;

  })();

  window.Q = new QueueEvent;

  Q = window.Q;

  drawer_dom = document.getElementById("drawing");

  drawer_dom.onmousemove = function(event) {
    var Bx, By, x, y, _ref;
    x = parseInt(event.clientX);
    y = parseInt(event.clientY);
    if (dashed_box) {
      dashed_box.remove();
    }
    _ref = locate_mouse(x, y), Bx = _ref[0], By = _ref[1];
    return dashed_box = draw.rect(dist, dist).move(By * dist - dist / 2, Bx * dist - dist / 2).attr({
      'stroke': 'black',
      'stroke-dasharray': [2, 2],
      'fill': 'white',
      'fill-opacity': 0
    });
  };

  clog(drawer_dom);

  drawer_dom.onclick = function(event) {
    var Bx, By, x, y, _ref;
    x = parseInt(event.clientX);
    y = parseInt(event.clientY);
    return _ref = Q.push(locate_mouse(x, y)), Bx = _ref[0], By = _ref[1], _ref;
  };

  window.add_black_dot = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0][0][0], x = _ref[0], y = _ref[1];
      clog("black dot: " + x + " " + y);
      return D.add(['black-dot', x, y](true));
    };
    return Q.bind(func, 1);
  };

  clog('init done');

}).call(this);
