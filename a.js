// Generated by CoffeeScript 1.6.3
(function() {
  var C_size, D, D_size, Painter, Q, QueueEvent, U_size, clog, dashed_box, dist, draw, drawer_dom, init_grids, init_op, locate_mouse, op, ops, redraw, _i, _len;

  clog = console.log;

  draw = SVG('drawing').size('400', '400');

  dist = 60;

  U_size = 40;

  C_size = 30;

  D_size = 12;

  init_grids = function() {
    var i, _i, _results;
    _results = [];
    for (i = _i = 1; _i <= 6; i = ++_i) {
      _results.push(draw.line(0, i * dist, 6 * dist, i * dist).stroke({
        width: 2
      }));
    }
    return _results;
  };

  window.ops = [];

  ops = window.ops;

  init_op = [['line', 1, 1, 3], ['line', 2, 1, 4], ['line', 3, 1, 3], ['black-dot', 1, 1], ['black-dot', 2, 2], ['black-dot', 3, 2], ['white-dot', 3, 3], ['black-dot', 4, 2], ['targ', 1, 2], ['targ', 3, 1], ['gate', 1, 3, 'U'], ['qswap', 4, 1]];

  Painter = (function() {
    function Painter(draw, ops) {
      this.draw = draw;
      this.ops = ops;
    }

    Painter.prototype.black_dot = function(x, y) {
      return draw.circle(D_size).move(y * dist - D_size / 2, x * dist - D_size / 2);
    };

    Painter.prototype.white_dot = function(x, y) {
      return draw.circle(D_size).move(y * dist - D_size / 2, x * dist - D_size / 2).attr({
        'stroke-width': 2,
        'fill': 'white',
        'fill-opacity': 1
      });
    };

    Painter.prototype.targ = function(x, y) {
      draw.circle(C_size).move(y * dist - C_size / 2, x * dist - C_size / 2).attr({
        'stroke-width': 2,
        'fill-opacity': 0
      });
      draw.line(y * dist - C_size / 2, x * dist, y * dist + C_size / 2, x * dist).stroke({
        width: 1
      });
      return draw.line(y * dist, x * dist - C_size / 2, y * dist, x * dist + C_size / 2).stroke({
        width: 1
      });
    };

    Painter.prototype.fix_line = function(c, L, R) {
      var cmd, op, x, y, _i, _len, _ref, _results;
      _results = [];
      for (_i = 0, _len = ops.length; _i < _len; _i++) {
        op = ops[_i];
        cmd = op[0];
        if (cmd === 'black-dot' || cmd === 'white-dot' || cmd === 'targ' || cmd === 'gate' || cmd === 'multigate') {
          _ref = op.slice(1, 3), x = _ref[0], y = _ref[1];
          if (y === c && (((L <= x && x <= R)) || ((L >= x && x >= R)))) {
            _results.push(this.add(op, false));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Painter.prototype.line = function(c, x, y) {
      draw.line(c * dist, x * dist, c * dist, y * dist).stroke({
        width: 1
      });
      return this.fix_line(c, x, y);
    };

    Painter.prototype.qswap = function(x, y) {
      draw.line(y * dist - 5, x * dist - 5, y * dist + 5, x * dist + 5).stroke({
        width: 3
      });
      return draw.line(y * dist + 5, x * dist - 5, y * dist - 5, x * dist + 5).stroke({
        width: 3
      });
    };

    Painter.prototype.gate = function(x, y, txt) {
      draw.rect(U_size, U_size).move(y * dist - U_size / 2, x * dist - U_size / 2).attr({
        'stroke': 'black',
        'fill': 'white',
        'fill-opacity': 1
      });
      return draw.image("http://frog.isima.fr/cgi-bin/bruno/tex2png--10.cgi?" + txt, 20, 20).move(y * dist - 10, x * dist - 10);
    };

    Painter.prototype.multigate = function(c, x, y, txt) {
      draw.rect(U_size, U_size + dist * Math.abs(y - x)).move(c * dist - U_size / 2, Math.min(x, y) * dist - U_size / 2).attr({
        'stroke': 'black',
        'fill': 'white',
        'fill-opacity': 1
      });
      return draw.image("http://frog.isima.fr/cgi-bin/bruno/tex2png--10.cgi?" + txt, 20, 20).move(c * dist - 10, (x + y) / 2 * dist - 10);
    };

    Painter.prototype.add = function(op, p) {
      var c, cmd, txt, x, y, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      cmd = op[0];
      if (p) {
        ops.push(op);
      }
      if (cmd === 'black-dot') {
        _ref = op.slice(1, 3), x = _ref[0], y = _ref[1];
        return this.black_dot(x, y);
      } else if (cmd === 'white-dot') {
        _ref1 = op.slice(1, 3), x = _ref1[0], y = _ref1[1];
        return this.white_dot(x, y);
      } else if (cmd === 'line') {
        _ref2 = op.slice(1, 4), c = _ref2[0], x = _ref2[1], y = _ref2[2];
        return this.line(c, x, y);
      } else if (cmd === 'targ') {
        _ref3 = op.slice(1, 3), x = _ref3[0], y = _ref3[1];
        return this.targ(x, y);
      } else if (cmd === 'gate') {
        _ref4 = op.slice(1, 4), x = _ref4[0], y = _ref4[1], txt = _ref4[2];
        return this.gate(x, y, txt);
      } else if (cmd === 'qswap') {
        _ref5 = op.slice(1, 3), x = _ref5[0], y = _ref5[1];
        return this.qswap(x, y);
      } else if (cmd === 'multigate') {
        _ref6 = op.slice(1, 5), c = _ref6[0], x = _ref6[1], y = _ref6[2], txt = _ref6[3];
        return this.multigate(c, x, y, txt);
      }
    };

    return Painter;

  })();

  D = new Painter(draw);

  dashed_box = null;

  redraw = function() {
    var op, _i, _len, _results;
    draw.clear();
    init_grids();
    _results = [];
    for (_i = 0, _len = ops.length; _i < _len; _i++) {
      op = ops[_i];
      _results.push(D.add(op, false));
    }
    return _results;
  };

  for (_i = 0, _len = init_op.length; _i < _len; _i++) {
    op = init_op[_i];
    D.add(op, true);
  }

  redraw();

  locate_mouse = function(x, y) {
    return [Math.floor(y / dist + 0.5), Math.floor(x / dist + 0.5)];
  };

  window.cancel_op = function() {
    if (ops.length === 0) {

    } else {
      ops = ops.slice(0, -1);
      return redraw();
    }
  };

  QueueEvent = (function() {
    function QueueEvent() {
      this.Q = [];
      this.func = null;
      this.cnt = 0;
    }

    QueueEvent.prototype.push = function(args) {
      this.Q.push(args);
      if (this.Q.length >= this.cnt && this.func) {
        this.func(this.Q.slice(0, +(this.cnt - 1) + 1 || 9e9));
        this.Q = [];
        return this.func = null;
      }
    };

    QueueEvent.prototype.bind = function(func, cnt) {
      this.func = func;
      this.cnt = cnt;
      return this.Q = [];
    };

    return QueueEvent;

  })();

  window.Q = new QueueEvent;

  Q = window.Q;

  drawer_dom = document.getElementById("drawing");

  drawer_dom.onmousemove = function(event) {
    var Bx, By, x, y, _ref;
    x = parseInt(event.clientX);
    y = parseInt(event.clientY);
    if (dashed_box) {
      dashed_box.remove();
    }
    _ref = locate_mouse(x, y), Bx = _ref[0], By = _ref[1];
    return dashed_box = draw.rect(dist, dist).move(By * dist - dist / 2, Bx * dist - dist / 2).attr({
      'stroke': 'black',
      'stroke-dasharray': [2, 2],
      'fill': 'white',
      'fill-opacity': 0
    });
  };

  drawer_dom.onclick = function(event) {
    var x, y;
    x = parseInt(event.clientX);
    y = parseInt(event.clientY);
    return Q.push(locate_mouse(x, y));
  };

  window.add_black_dot = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0], x = _ref[0], y = _ref[1];
      return D.add(['black-dot', x, y], true);
    };
    return Q.bind(func, 1);
  };

  window.add_white_dot = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0], x = _ref[0], y = _ref[1];
      return D.add(['white-dot', x, y], true);
    };
    return Q.bind(func, 1);
  };

  window.add_targ = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0], x = _ref[0], y = _ref[1];
      return D.add(['targ', x, y], true);
    };
    return Q.bind(func, 1);
  };

  window.add_qswap = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0], x = _ref[0], y = _ref[1];
      return D.add(['qswap', x, y], true);
    };
    return Q.bind(func, 1);
  };

  window.add_gate = function() {
    var func;
    func = function(arg) {
      var x, y, _ref;
      _ref = arg[0], x = _ref[0], y = _ref[1];
      return D.add(['gate', x, y, $('#gate').val()], true);
    };
    return Q.bind(func, 1);
  };

  window.add_multigate = function() {
    var func;
    func = function(arg) {
      var x1, x2, y1, y2, _ref, _ref1;
      _ref = arg[0], x1 = _ref[0], y1 = _ref[1];
      _ref1 = arg[1], x2 = _ref1[0], y2 = _ref1[1];
      if (y1 === y2) {
        return D.add(['multigate', y1, x1, x2, $('#gate').val()], true);
      }
    };
    return Q.bind(func, 2);
  };

  window.add_line = function() {
    var func;
    func = function(arg) {
      var x1, x2, y1, y2, _ref, _ref1;
      _ref = arg[0], x1 = _ref[0], y1 = _ref[1];
      _ref1 = arg[1], x2 = _ref1[0], y2 = _ref1[1];
      if (y1 === y2) {
        return D.add(['line', y1, x1, x2], true);
      }
    };
    return Q.bind(func, 2);
  };

}).call(this);
